// let myVar = 100 + 234;
// myVar += 123;
// myVar += 200 + 400;
// myVar += 335 + 180;
// console.log(myVar);




// https://www.youtube.com/watch?v=wv3mKV_NlCs

let hater = {
    firstName: 'Билл',
    lastName: 'Гейтс',
    getName() {
//        return this.firstName + ' ' + this.lastName;
        return `${this.firstName} ${this.lastName}`;
    }
}

hater.age = 66;
console.log(hater);
console.log(hater.getName());

let hater2 = {
    firstName: 'Марк',
    lastName: 'Цукерберг',
    getName() {
        return `${this.firstName} ${this.lastName}`;
    }
}

hater2.age = 35;
console.log(hater2);
console.log(hater2.getName());

// Проще созать класс который мы будем использовать для создания объекта
// конструктор в классе это по сути обычная функция, единственное его отличие, - АВТОЗАПУСК

(function() {
    console.log("we are anonymous");
})();

// anonym();
// Также конструктор, как только мы создаем экземпляр данного класса, то есть берем заготовочку для создания 
// конкретного "хейтера", - он автоматически запускается и поэтому его используют для задания начальных значений для свойств класса
// создаем constructor - имя этого метода всегда так называется, далее, как и у обычной функции у него есть скобки  
// в которых мы можем указывать параметры, а в фигурных скобках мы можем писать любой код, который мы хотим запускать 
/* при использовании экземпляра
class Hater {
//   constructor(params) {
    constructor(n) {
//      console.log('привет, я конструктор');
        console.log('привет, я конструктор' + n);
   } 
}
// Теперь, чтобы создать нового хейтера из этой й заготовки, используйте ключевое слово "new" и имя класса:
// то есть это как взять заготовочку из дерева и сделать из него новый объект, а также поставить круглые скобки

new Hater();

// Сохраняем и видим, что код, который находится внутри метода "constructor" автоматически запустился
// Мы можем создать столько объектов "хейтеров" из класса Hater, сколько нам надо 
// давайте добавим параметр "n" и передадим его в конструктор: constructor(n)
new Hater(1);

new Hater(2);

new Hater(3);
// Видите, это разные объекты класса Hater, - первый экземпляр, второй экземпляр, третий 
*/
// Теперь добавим свойств как в объекте, мы можем добавить имя и фамилию, свойства мы добавим прямо в конструкторе
// для определения свойств мы должны использовать контекст "this" и уже потом наименование свойства - указываем имя: this.firstName
// так как это класс, а не конкретный "хейтер", то задавать жестко имя в конструкторе мы не будем, - мы будем принимать его 
// из параметра, который передадим конструктору и присваивать свойство внутри конструктора: 

class Hater {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;        // таким же образом создадим фамилию. Свойству присваиваем значение, пришедшее из параметра вызова конструктора 
    } 
                        // Теперь внутри класса создаём метод, который будет выводить в консоль имя нашего "хейтера" с фамилией; назовём его "sayName"
    sayName()  {     // В отличие от объектов, мы тут не используем запятые между методами
        console.log(`my name is ${this.firstName} and my surname is ${this.lastName}`);
    }
}

//Как передать в эти параметры (this.firstName и this.lastName) значения - легко: они указываются в момент создания экземпрляра:
new Hater('Норман', 'Озборн');

/* Чтобы вызвать метод, который не вызывается как конструктор при создании экземпляра "хейтера",
мы должны присвоить конкретного хейтера переменной  */

let hater1 = new Hater('Норман', 'Озборн');

// Затем уже, как и в объекте, через точку обращаемся к методу, а точнее, - вызываем его, указывая скобки:
hater1.sayName();

let hater3 = new Hater('Демо', 'Крат');
hater3.sayName();

/* Это намного удобнее, чем каждый раз создавать однотипные объекты, как мы это делали вначале.
Что происходит при создании экземпляра? 
Ма передаём в конструктор имя, получаем его в конструкторе 
и присваиваем свойству внутри класса (this.firstName = firstName;) то, что у них имена одинаковые никак не сказывается на них 
так как параметр firstName не покидает функцию, а свойство this.firstName вообще вне этого контекста, 
аналогично передаем фамилию и присваиваем другому свойству.
Затем вызываем метод, а метод выводит в консоль свойства, которым мы присвоили значения */

/* создадим класс Bloger, в конструкторе добавим параметр, который будет принимать наименование канала.
 в метод, который выводил имя и фамилию, добавим наименование канала; при создании экземпляра, добавим имя, фамилию и название канала,
 а затем вызовем метод, чтобы он вывел строку вот в таком виде 
 Канал LetsCode [автор канала: Андрей Сидоренко]            */

 class Bloger {
    constructor (channel, firstName, lastName) {
        this.channel = channel;
        this.firstName = firstName;
        this.lastName = lastName;
    }
    printBloger() {
        console.log(`Канал ${this.channel} [автор канала: ${this.firstName} ${this.lastName}]`);
    }

 }

 let bloger1 = new Bloger('LetsCode', 'Андрей', 'Андрей');
 bloger1.printBloger();

 console.log(bloger1);

 